---
// Для статической генерации используем русский язык по умолчанию
const localeTexts = await import('../locales/ru.json');
const title = localeTexts.title;
const header = localeTexts.header;
---

<header>
	<canvas id="header-canvas"></canvas>
	<nav>
		<h2><a href="/">{title}</a></h2>
		<div class="internal-links">
			{header.map((link: any) =>
				<a href={link.href}>{link.text}</a>
			)}
		</div>
		<div class="controls">
			<button id="theme-toggle" class="control-button" title="Toggle Theme" aria-label="Toggle Theme">
				<iconify-icon icon="mdi:theme-light-dark" width="20" height="20"></iconify-icon>
				<span class="button-text">Theme</span>
			</button>
			<button id="lang-toggle" class="control-button" title="Toggle Language" aria-label="Toggle Language">
				<iconify-icon icon="mdi:translate" width="20" height="20"></iconify-icon>
				<span class="button-text" id="lang-text">RU</span>
			</button>
		</div>
	</nav>
</header>

<style>
	header {
		margin: 0;
		padding: 0 1em;
		background: rgba(255, 255, 255, .6);
		box-shadow: 0 2px 8px rgba(var(--black), 5%);
		position: sticky;
		top: 0;
		overflow: hidden;
		background: white;
		transition: background-color 0.3s ease, box-shadow 0.3s ease;
	}

	:global(body.dark-theme) header {
		background: rgba(30, 30, 30, 0.95);
		box-shadow: 0 2px 8px rgba(0, 0, 0, 20%);
	}

	h2 {
		margin: 0;
		font-size: 1em;
		display: flex;
		justify-content: center;
	}

	h2 a,
	h2 a.active {
		text-decoration: none;
		transition: color 0.3s ease;
	}
	
	nav {
		display: flex;
		align-items: center;
		justify-content: space-between;
		position: relative;
		z-index: 1;
		background: rgba(255, 255, 255, 0.6);
		transition: background-color 0.3s ease;
	}

	:global(body.dark-theme) nav {
		background: rgba(30, 30, 30, 0.6);
	}
	
	nav a {
		padding: .65em .65em;
		color: var(--black);
		border-bottom: 4px solid transparent;
		text-decoration: none;
		font-size: clamp(0.1rem, 1vw + 0.5rem, 1.1rem);
		transition: color 0.3s ease, border-color 0.3s ease;
	}

	:global(body.dark-theme) nav a {
		color: #e0e0e0;
	}
	
	nav a.active {
		text-decoration: none;
		border-bottom-color: var(--accent);
	}
	
	.controls {
		display: flex;
		align-items: center;
		gap: 0.5rem;
	}

	.control-button {
		display: flex;
		align-items: center;
		gap: 0.5rem;
		padding: 0.5rem 1rem;
		background: rgba(var(--accent), 0.1);
		border: 1px solid rgba(var(--accent), 0.3);
		border-radius: 6px;
		color: var(--accent);
		cursor: pointer;
		font-size: 0.9rem;
		font-weight: 500;
		transition: all 0.2s ease;
		text-decoration: none;
	}

	.control-button:hover {
		background: rgba(var(--accent), 0.2);
		border-color: rgba(var(--accent), 0.5);
		transform: translateY(-1px);
	}

	.control-button:active {
		transform: translateY(0);
	}

	:global(body.dark-theme) .control-button {
		background: rgba(255, 255, 255, 0.1);
		border-color: rgba(255, 255, 255, 0.3);
		color: #e0e0e0;
	}

	:global(body.dark-theme) .control-button:hover {
		background: rgba(255, 255, 255, 0.2);
		border-color: rgba(255, 255, 255, 0.5);
	}

	.button-text {
		font-family: inherit;
	}
	
	@media (max-width: 720px) {
		.button-text {
			display: none;
		}
		
		.control-button {
			padding: 0.5rem;
		}
	}

	#header-canvas {
		position: absolute;
		width: 100%;
		height: 150%;
		z-index: -1;
	}

	.internal-links {
		text-align: center;
	}
</style>

<script>
	import 'iconify-icon';
</script>

<script type="application/javascript" is:inline>
	// Theme management
	function initTheme() {
		// Check for saved theme or default to light
		const savedTheme = localStorage.getItem('theme');
		const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
		const theme = savedTheme || (prefersDark ? 'dark' : 'light');
		
		document.body.classList.toggle('dark-theme', theme === 'dark');
		updateThemeIcon(theme);
	}

	function toggleTheme() {
		const isDark = document.body.classList.contains('dark-theme');
		const newTheme = isDark ? 'light' : 'dark';
		
		document.body.classList.toggle('dark-theme', newTheme === 'dark');
		localStorage.setItem('theme', newTheme);
		updateThemeIcon(newTheme);
	}

	function updateThemeIcon(theme) {
		const themeButton = document.getElementById('theme-toggle');
		const icon = themeButton?.querySelector('iconify-icon');
		if (icon) {
			icon.setAttribute('icon', theme === 'dark' ? 'mdi:weather-sunny' : 'mdi:weather-night');
		}
	}

	function updateLanguageButton() {
		const langButton = document.getElementById('lang-text');
		const currentLang = localStorage.getItem('preferred-language') || 'ru';
		if (langButton) {
			langButton.textContent = currentLang.toUpperCase();
		}
	}

	// Canvas animation code
	function saveDotPositions(points) {
		const dots = points.map(point => ({
			x: point.x,
			y: point.y,
			vx: point.vx,
			vy: point.vy
		}));
		localStorage.setItem('dotPositions', JSON.stringify(dots));
	}

	function loadDotPositions() {
		const storedDots = localStorage.getItem('dotPositions');
		return storedDots ? JSON.parse(storedDots) : [];
	}

	document.addEventListener("DOMContentLoaded", () => {
		// Initialize theme
		initTheme();
		updateLanguageButton();

		// Theme toggle event listener
		const themeToggle = document.getElementById('theme-toggle');
		if (themeToggle) {
			themeToggle.addEventListener('click', toggleTheme);
		}

		// Listen for theme changes from system
		window.matchMedia('(prefers-color-scheme: dark)').addListener((e) => {
			if (!localStorage.getItem('theme')) {
				document.body.classList.toggle('dark-theme', e.matches);
				updateThemeIcon(e.matches ? 'dark' : 'light');
			}
		});

		// Canvas setup
		const canvas = document.getElementById("header-canvas");
		const ctx = canvas.getContext("2d");
		const points = [];
		const pointCount = 50;
		const maxDistance = 100;

		function resizeCanvas() {
			canvas.width = canvas.offsetWidth;
			canvas.height = canvas.offsetHeight;
		}

		resizeCanvas();
		window.addEventListener('resize', resizeCanvas);

		class Point {
			constructor(x = Math.random() * canvas.width, y = Math.random() * canvas.height, vx = (Math.random() - 0.5), vy = (Math.random() - 0.5)) {
				this.x = x;
				this.y = y;
				this.vx = vx;
				this.vy = vy;
			}

			update() {
				this.x += this.vx;
				this.y += this.vy;

				if (this.x < 0 || this.x > canvas.width) this.vx *= -1;
				if (this.y < 0 || this.y > canvas.height) this.vy *= -1;
			}
		}

		const savedDots = loadDotPositions();
		if (savedDots.length > 0) {
			savedDots.forEach(dot => points.push(new Point(dot.x, dot.y, dot.vx, dot.vy)));
		} else {
			for (let i = 0; i < pointCount; i++) {
				points.push(new Point());
			}
		}

		function draw() {
			ctx.clearRect(0, 0, canvas.width, canvas.height);

			// Get theme-aware colors
			const isDark = document.body.classList.contains('dark-theme');
			const dotColor = isDark ? "white" : "black";
			const lineColor = isDark ? "255, 255, 255" : "0, 0, 0";

			points.forEach(point => {
				ctx.beginPath();
				ctx.arc(point.x, point.y, 2, 0, Math.PI * 2);
				ctx.fillStyle = dotColor;
				ctx.fill();
			});

			for (let i = 0; i < points.length; i++) {
				for (let j = i + 1; j < points.length; j++) {
					const dx = points[i].x - points[j].x;
					const dy = points[i].y - points[j].y;
					const distance = Math.sqrt(dx * dx + dy * dy);

					if (distance < maxDistance) {
						ctx.beginPath();
						ctx.moveTo(points[i].x, points[i].y);
						ctx.lineTo(points[j].x, points[j].y);
						ctx.strokeStyle = `rgba(${lineColor}, ${1 - distance / maxDistance})`;
						ctx.stroke();
					}
				}
			}

			points.forEach(point => point.update());
			requestAnimationFrame(draw);
		}

		window.addEventListener('beforeunload', () => saveDotPositions(points));

		draw();
	});
</script>
